#include <iostream>
#include <fstream>
//#include <cctype>
#include <vector>
//#include <algorithm>
using namespace std;

// strings containing the info in each sequence 
string seq1, seq2, seq3, seq4, seq5, seq6, seq7, seq8, seq9;
// strings relating the sequence names to respective sequence 
string Rseq1, Rseq2, Rseq3, Rseq4, Rseq5, Rseq6, Rseq7, Rseq8, Rseq9;

string read;
int seqCounter = 1;

// set input variable to file 
ifstream input("BB20001.msf");
// set output file
ofstream output;

string OutputSequenceName(int value){
    if (value == 1)
        return seq1;
    if (value == 2)
        return seq2;
    if (value == 3)
        return seq3;
    if (value == 4)
        return seq4;
    if (value == 5)
        return seq5;
    if (value == 6)
        return seq6;
}

// function that prints out the info of each sequence that have been recorded 
void listSequenceInfo(int value){
    cout << "\nListing Sequence Info [" << value << "]: " << OutputSequenceName(value) << "\n";
    if (value == 1){
        for (int i = 0; i <= Rseq1.length(); i++){
            cout << Rseq1[i];
        }
    }

    if (value == 2){
        for (int i = 0; i <= Rseq2.length(); i++){
            cout << Rseq2[i];
        }
    }

    if (value == 3){
        for (int i = 0; i <= Rseq3.length(); i++){
            cout << Rseq3[i];
        }
    }

    if (value == 4){
        for (int i = 0; i <= Rseq4.length(); i++){
            cout << Rseq4[i];
        }
    }

    if (value == 5){
        for (int i = 0; i <= Rseq5.length(); i++){
            cout << Rseq5[i];
        }
    }

    if (value == 6){
        for (int i = 0; i <= Rseq6.length(); i++){
            cout << Rseq6[i];
        }
    }
    cout << "\nEnd Sequence [" << value << "]\n";
}

void recordSequenceNames(){
    while (true){
            getline(input, read, '\n');
            if (read[1] == 'N' && read[5] == ':'){  // if current read value contains N and : in Name: then collect info
                // collect the info from the current read line, since it contains sequence info 
                // loop begins at index 7 of read line, per their formatting design
                // depending on the current # of read lines, this loop will populate the respective sequence
                for (int i = 7; i <= 20; i++){
                    // if current index in read is 'space' then break since end of name
                    if (read[i] == ' '){break;}
                    if (seqCounter == 1){seq1.push_back(read[i]);}
                    if (seqCounter == 2){seq2.push_back(read[i]);}
                    if (seqCounter == 3){seq3.push_back(read[i]);}
                    if (seqCounter == 4){seq4.push_back(read[i]);}
                    if (seqCounter == 5){seq5.push_back(read[i]);}
                    if (seqCounter == 6){seq6.push_back(read[i]);}
                }
                seqCounter++; // current read line info has been extracted, increment by 1 so that next line will be sent to the next sequence
                // only collects first 6 sequences, wasted execution time but meh it works
            }
            // check if at the end of listing sequence names
            if (read[0] == '/' && read[1] == '/'){ 
                cout << "Detected '//'" << endl;
                break;
            }
        }
}


int checkMatch(int in){
    int i = 0;
    if (in == 1){
        while (read[i] != ' '){
            if (read[i] != seq1[i] && read[i] != ' ')
                return 0; 
            i++;
        }
    }

    if (in == 2){
        while (read[i] != ' '){
            if (read[i] != seq2[i] && read[i] != ' ')
                return 0; 
            i++;
        }
    }

    if (in == 3){
        while (read[i] != ' '){
            if (read[i] != seq3[i] && read[i] != ' ')
                return 0; 
            i++;
        }
    }

    if (in == 4){
        while (read[i] != ' '){
            if (read[i] != seq4[i] && read[i] != ' ')
                return 0; 
            i++;
        }
    }

    if (in == 5){
        while (read[i] != ' '){
            if (read[i] != seq5[i] && read[i] != ' ')
                return 0; 
            i++;
        }
    }

    if (in == 6){
        while (read[i] != ' '){
            if (read[i] != seq6[i] && read[i] != ' ')
                return 0; 
            i++;
        }
    }

    return 1;
}

void recordSequenceData(){
    while (input.good()){
        getline(input, read);
        // check what chars match the recorded sequence names 

        if (read[0] == seq1[0]){
            if (checkMatch(1)){ // check if the current line contains the same seq Name as seq1
                int r = seq1.length();  // set r = to seq1 names length
                int k = read.length();
                while (r <= k){    // while current index of read variable isn't at the end of the curr line
                    if (read[r] != ' ' && read[r] != '\n')  // if current index in line isn't space or end of line
                        Rseq1.push_back(read[r]);           // add current sequence sequence index info into corresponding sequence
                    r++;
                }
                Rseq1.pop_back();
            }
        }

        if (read[0] == seq2[0]){
            if (checkMatch(2)){ // check if the current line contains the same seq Name as seq2
                int r = seq2.length();  // set r = to seq1 names length
                int k = read.length();
                while (r <= k){    // while current index of read variable isn't at the end of the curr line
                    if (read[r] != ' ' && read[r] != '\n')  // if current index in line isn't space or end of line
                        Rseq2.push_back(read[r]);           // add current sequence sequence index info into corresponding sequence
                    r++;
                }
                Rseq2.pop_back();
            }
        }

        if (read[0] == seq3[0]){
            if (checkMatch(3)){ // check if the current line contains the same seq Name as seq3
                int r = seq3.length();  // set r = to seq1 names length
                int k = read.length();
                while (r <= k){    // while current index of read variable isn't at the end of the curr line
                    if (read[r] != ' ' && read[r] != '\n')  // if current index in line isn't space or end of line
                        Rseq3.push_back(read[r]);           // add current sequence sequence index info into corresponding sequence
                    r++;
                }
                Rseq3.pop_back();
            }
        }

        if (read[0] == seq4[0]){
            if (checkMatch(4)){ // check if the current line contains the same seq Name as seq4
                int r = seq4.length();  // set r = to seq1 names length
                int k = read.length();
                while (r <= k){    // while current index of read variable isn't at the end of the curr line
                    if (read[r] != ' ' && read[r] != '\n')  // if current index in line isn't space or end of line
                        Rseq4.push_back(read[r]);           // add current sequence sequence index info into corresponding sequence
                    r++;
                }
                Rseq4.pop_back();
            }
        }

        if (read[0] == seq5[0]){
            if (checkMatch(5)){ // check if the current line contains the same seq Name as seq5
                int r = seq5.length();  // set r = to seq1 names length
                int k = read.length();
                while (r <= k){    // while current index of read variable isn't at the end of the curr line
                    if (read[r] != ' ' && read[r] != '\n')  // if current index in line isn't space or end of line
                        Rseq5.push_back(read[r]);           // add current sequence sequence index info into corresponding sequence
                    r++;
                }
                Rseq5.pop_back();
            }
        }

        if (read[0] == seq6[0]){
            if (checkMatch(6)){ // check if the current line contains the same seq Name as seq6
                int r = seq6.length();  // set r = to seq1 names length
                int k = read.length();
                while (r <= k){    // while current index of read variable isn't at the end of the curr line
                    if (read[r] != ' ' && read[r] != '\n')  // if current index in line isn't space or end of line
                        Rseq6.push_back(read[r]);           // add current sequence sequence index info into corresponding sequence
                    r++;
                }
                Rseq6.pop_back();
            }
        }      
    }
}


            // col   ltr 
int occurences[1000][27];
char amino[27] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','.'};
void generateHistogram(){
    // go through each column
    for (int i = 0; i <= Rseq1.length(); i++){
        // gather the values of each sequence in that column
        char curr[5] = {Rseq1[i], Rseq2[i], Rseq3[i], Rseq4[i], Rseq5[i]};

        // nested for loop to count occurences of given letter
        for (int j = 0; j <= 4; j++){  // goes through each index of curr 
            for (int k = 0; k <= 26; k++){ // go through each letter in amino
                if (curr[j] == amino[k]){
                    occurences[i][k] += 1; 
                }
            }
        }
    }
}

void printHistogram(){
    for (int i = 0; i <= 999; i++){
            cout << "Col [" << i << "]: "; 
            for (int k = 0; k <= 26; k++){
                cout << occurences[i][k]; 
            }
            cout << endl;
        }
}

float ratios[1000][27];
void getRatio(){
    float a, b = 5;
    for (int i = 0; i <= 999; i++){ // go through each column
        for (int j = 0; j <= 26; j++){
            a = occurences[i][j];
            ratios[i][j] = (a / b);
        }
    }
}

void printRatios(){
    for (int i = 0; i <= 999; i++){
            cout << "Col [" << i << "]: "; 
            for (int k = 0; k <= 26; k++){
                cout << ratios[i][k] << " "; 
            }
            cout << endl;
        }
}

int coreValues[26];
void selectCoreBlocks(){
    // 564, 569, 580, 585-596, 607-612, 635-639
    // 26 core blocks to consider
    coreValues[0] = 564;
    coreValues[1] = 569;
    coreValues[2] = 580;
    int counter = 585;
    for (int i = 3; i <= 14; i++){
        coreValues[i] = counter;
        counter++;
    }
    counter = 607;
    for (int i = 15; i <= 20; i++){
        coreValues[i] = counter;
        counter++;
    }
    counter = 635;
    for (int i = 21; i <= 25; i++){
        coreValues[i] = counter;
        counter++;
    }
}

void printCoreBlocks(){
    cout << "\n Core Block Values: ";
    for (int i = 0; i <= 25; i++){
        cout << coreValues[i] << " ";
    }
}

void showUsedLetters(){
    float testset[27];
        for (int i = 0; i <= 999; i++){ 
            for (int k = 0; k <= 26; k++){
                testset[k] += ratios[i][k]; 
            }
            cout << endl;
        }

        for (int i = 0; i <= 26; i++){
            cout << testset[i] << " "; 
        }
}

// int CoreSequence[5][26];
// void generateCoreSequence(){
//     int temp;
//     for (int i = 0; i <= 25; i++){
//         temp = coreValues[i];
//         CoreSequence[0][i] = Rseq1[temp];
//         cout << coreValues << " - " << CoreSequence[0][i] << endl;
//     }

//     for (int i = 0; i <= 25; i++){
//         temp = coreValues[i];
//         CoreSequence[1][i] = Rseq2[temp];
//     }

//     for (int i = 0; i <= 25; i++){
//         temp = coreValues[i];
//         CoreSequence[2][i] = Rseq3[temp];
//     }

//     for (int i = 0; i <= 25; i++){
//         temp = coreValues[i];
//         CoreSequence[3][i] = Rseq4[temp];
//     }

//     for (int i = 0; i <= 25; i++){
//         temp = coreValues[i];
//         CoreSequence[4][i] = Rseq5[temp];
//     }
// }

// void printCoreSequences(){
//     cout << "\n Core Sequence Values: ";
//     for (int i = 0; i <= 4; i++){
//         cout << "\n [" << i << "] ";
//         for (int j = 0; j <= 25; j++){
//             cout << CoreSequence[i][j] << " ";
//         }
//     }
// }

struct states{
    int state;

    int L1, L2, L3, L4, L5;  // letters spotted in ratios
    float R1, R2, R3, R4, R5;  // ratios of spotted letters
    // If Ln == 99, then there is a repeat since 99 is empty value
    // If Rn == 0, then Ln should == 99

    // tTm = this state to match     tTi = this state to insert     tTd = this to deletion 
    // these three should all add up to 1 for a given state
    float tTm, tTi, tTd;
};

vector <states> results;
void generateHMM(){
    int track, cvcount; // corevalue count to track which position in core block 
    // 25 is size of corevalues array
    states beginState;
    beginState.state = -1;          // these lines create the begin state, with prob of going to match or insertion being .5 each
    beginState.tTm = 0.5;
    beginState.tTi = 0.5;
    results.push_back(beginState);
    for (int i = 0; i <= 25; i++){  // each state
        // get each ratio value of each core block column
        int seen[5] = {99,99,99,99,99};
        float ratio_seen[5] = {0,0,0,0,0};
        track = 0;
        cvcount = coreValues[i];    // core value count is the current index of core block in corevalues ex 565 is at coreValues[0]
        states currState;    // make new struct for current state
        currState.state = i;
        for (int j = 0; j <= 26; j++){ 
            if (ratios[cvcount][j] > 0){    // check ratios at columns where core blocks are, checking each letter i if its greater than zero
                seen[track] = j;    // store letter corresponding number 
                ratio_seen[track] = ratios[cvcount][j]; // store ratio of spotted letter
                track++;
            }
        }

        //    || 564 || 569 || 580 || 585-596 || 607-612 || 635-639 ||
        if (coreValues[i] == 564 || coreValues[i] == 569 || coreValues[i] == 580 || coreValues[i] == 596 || coreValues[i] == 612 || coreValues[i] == 639){
            currState.tTi = 0.8;
            currState.tTm = 0.1;
            currState.tTd = 0.1;  // only possible is an insertion where it becomes divergent 
        }

        currState.L1 = seen[0];
        currState.L2 = seen[1];
        currState.L3 = seen[2];
        currState.L4 = seen[3];
        currState.L5 = seen[4];

        currState.R1 = ratio_seen[0];
        currState.R2 = ratio_seen[1];
        currState.R3 = ratio_seen[2];
        currState.R4 = ratio_seen[3];
        currState.R5 = ratio_seen[4];

        results.push_back(currState);
    }

    for (int i = 0; i <= 25; i++){  // go through each state to determine tTm tTi tTd values
        if (coreValues[i] != 564 && coreValues[i] != 569 && coreValues[i] != 580 && coreValues[i] != 596 && coreValues[i] != 612 && coreValues[i] != 639){
            results[i].tTm = 0.8; 
            results[i].tTd = 0.1; // with current sequences, deletions are not very likely
            results[i].tTi = 0.1; // same goes for insertion
            // with current understanding, only giving deletion and insertion a small chance due to pseudocounts
        }
    }
    
}

void printMatches(){
    for (int i = 0; i <= (results.size() - 1); i++){
            cout << "State: " << results[i].state << "\n";
            cout << "L1: " << results[i].L1 << " - " << results[i].R1 << endl;
            cout << "L2: " << results[i].L2 << " - " << results[i].R2 << endl;
            cout << "L3: " << results[i].L3 << " - " << results[i].R3 << endl;
            cout << "L4: " << results[i].L4 << " - " << results[i].R4 << endl;
            cout << "L5: " << results[i].L5 << " - " << results[i].R5 << endl;
            cout << "tTm = " << results[i].tTm << " | tTi = " << results[i].tTi << " | tTd = " << results[i].tTd << endl;
            cout << endl;
        }
}

struct sequence{
    string seq;
    float prob;
};

vector<float> final;
int gCount1, gCount2;
void doingCalc(){
    for (int i = 0; i <= 3; i++){

    }
}

float totalOut;
void calculateProb(){
    char corrChar, nextCorrChar;
    int corrCore, nextCorrCore;
    totalOut = 1;
    for (int i = 0; i <= 24; i++){  // use current i in Rseq1 to determine where to go 
        corrCore = coreValues[i];
        nextCorrCore = coreValues[i+1];
        corrChar = Rseq1[corrCore]; // get letter from core block value in sequence 1
        nextCorrChar = Rseq1[nextCorrCore]; // get next letter from core block value in sequence 1
        for (int j = 0; j <= 4; j++){
            for (int k = 0; k <= 27; k++){ // go thru corr letter in seq
                if (amino[k] == nextCorrChar){
                    // now match see corresponding value 
                    if (j == 0){
                        totalOut == totalOut*results[i].R1; break;
                    }
                    if (j == 1){
                        totalOut == totalOut*results[i].R2; break;
                    }
                    if (j == 2){
                        totalOut == totalOut*results[i].R3; break; 
                    }
                    if (j == 3){
                        totalOut == totalOut*results[i].R4; break;
                    }
                    if (j == 4){
                        totalOut == totalOut*results[i].R5; break; 
                    }
                }
            }
        }
        // for (int j = 0; j <= 27; j++){
        //     for (int k = 0; k <= 4; k++){
        //         if (amino[k] == nextCorrChar){

        //         }
        //     }
        // }
  
    }
    cout << "\n Chance of Sequence 1: " << totalOut;
    totalOut = 0;
}
    

int main(){

    // check if file can be openend 
    if (!input.is_open()) cout << "Error opening file\n";

    //output.open("out.csv");
    // while not eof
    while(input.good()){
        
        cout << "Phase 1 start: Collect sequence names...";
        recordSequenceNames();
        cout << "Phase 1 complete: Collected sequence names.";

        cout << "Phase 2 start: Collect sequence details...\n";
        recordSequenceData();
        cout << "Phase 2 complete: Collected sequence details.\n";

        // list out the names and info stored in each sequence gathered
        for (int i = 1; i <= 5; i++){
            listSequenceInfo(i);
            cout << endl;
        }

        cout << "Phase 3 start: Gather histogram of occurences...\n";
        generateHistogram();
        cout << "Phase 3 complete: Gathered histogram values.\n";
        //printHistogram();

        cout << "Phase 4 start: Generate ratios of histogram...\n";
        getRatio();
        //printRatios();
        cout << "Phase 4 complete: Ratios calculated.\n";

        cout << "Phase 5 start: Selecting core blocks...\n";
        selectCoreBlocks();
        //printCoreBlocks();
        cout << "Phase 5 complete: Core block values recorded.\n";

        //cout << "Phase 6 start: Populate core value sequences...\n";
        //generateCoreSequence();
        //printCoreSequences();

        //showUsedLetters();  // concluded that Z is the only letter not used in the sequences

        generateHMM();

        
        // for (int i = 0; i <= 25; i++){
        //     int tmp1 = coreValues[i];
        //     cout << Rseq1[tmp1];
        //     //cout << coreValues[i] << " ";
        // }



        printMatches();
        
        //    || 564 || 569 || 580 || 585-596 || 607-612 || 635-639 ||
        // 26 core blocks to consider

        calculateProb();

        break;








        // read line up to the prelimiter which is ; 
        // for the last getline looking at y, it will be looking for \n for new line
        //getline(input, age, ';');

    } // end 1st loop

} // end main
